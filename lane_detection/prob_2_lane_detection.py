# -*- coding: utf-8 -*-
"""lane_detection_it1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hzRE046sGhe7dEURNS22-vBX0pqg5Y3K
"""

import cv2
import numpy as np

frames = []
cap = cv2.VideoCapture('whiteline.mp4')
if (cap.isOpened() == False):
	print("Unable to open the video file")
else:
  print('the video is stored in the cap variable')
video_output = cv2.VideoWriter('lane_det.avi',cv2.VideoWriter_fourcc(*'DIVX'), 25, (960,540))

"""tried homography first (but lot of noise)"""

while(cap.isOpened()):
        ret, frame = cap.read()
        if ret == True:        
           
            image = np.copy(frame)
            # image = cv2.flip(image, 1)


            #blurring the frame for noise reduction
            image = cv2.GaussianBlur(image,(3,3), 0)
            image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            height, width = image_gray.shape
            
            triangle = np.array([
                                [20, height],[(width/2)-110, height/1.7], [(width/2)+110, height/1.7], [width-20, height]
                                ])
            window_size_w = int(width/2)
            window_size_h = int(height/1.8)
            dst_pts  = np.array([
                                [0, window_size_h],[0, 0], [window_size_w, 0], [window_size_w, window_size_h]
                                ])
            M, mask = cv2.findHomography(triangle, dst_pts)
            im_out = cv2.warpPerspective(image, M, (window_size_w,window_size_h))
            edges = cv2.Canny(im_out,50,200)
            cdst = cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR)
            rho = 1
            theta = np.pi/180 #1 deg
            threshold = 30
            minLineLength = 40                                      
            maxLineGap = 15                      
            linesP = cv2.HoughLinesP(edges, rho, theta, threshold, None, minLineLength, maxLineGap)
            max_pts = np.array(linesP[0][0].shape)
            min_pts = np.array(linesP[0][0].shape)
            max_len = 0
            min_len = np.inf
            if linesP is not None:
                for i in range(0, len(linesP)):
                    l = linesP[i][0]
                    if np.linalg.norm(l[0:2] - l[2:4])>max_len:
                        max_len = np.linalg.norm(l[0:2] - l[2:4])
                        max_pts = l
            slope = (max_pts[3] - max_pts[1])/(max_pts[2] - max_pts[0])



####################for plotting solid line####################
            list_s = []
            y_array_s = []
            solid_array = []
            if linesP is not None:
                for i in range(0, len(linesP)):
                    l = linesP[i][0]
                    slope_s = (l[3] - l[1])/(l[2] - l[0])
                    if np.sign(slope_s)== np.sign(slope):
                        list_s.append(l[0])
                        list_s.append(l[2])
                        y_array_s.append(l[1])
                        y_array_s.append(l[3])
                        solid_array.append([l[0],l[1]])
                        solid_array.append([l[2],l[3]])
            if (len(solid_array)>=4):
        
                list_s = np.array(list_s)
                A_s = np.vstack([list_s, np.ones(len(list_s))]).T
                y_array_s = np.array(y_array_s)
                m_s, c_s = np.linalg.lstsq(A_s, y_array_s, rcond=None)[0]
                y_plot_1_s = height-40 
                x_plot_1_s = int((y_plot_1_s - c_s)/m_s)
                y_plot_2_s = 150
                x_plot_2_s = int((y_plot_2_s - c_s)/m_s)
                cv2.line(im_out, (x_plot_1_s, y_plot_1_s), (x_plot_2_s, y_plot_2_s), (0,255,0), 10, cv2.LINE_AA)

            else:
                cv2.line(im_out, (x_plot_1_s, y_plot_1_s), (x_plot_2_s, y_plot_2_s), (0,255,0), 10, cv2.LINE_AA)


###################################################################


####################for plotting dotted line####################
            if max_pts[1]<max_pts[3]:
                sorted_max = max_pts[0]     
            else:
                sorted_max = max_pts[2]
            x_array = []
            y_array = []
            min_array = []
            if linesP is not None:
                for i in range(0, len(linesP)):
                    l = linesP[i][0]
                    # if np.linalg.norm(l[0:2] - l[2:4])<min_len:
                    slope_d = (l[3] - l[1])/(l[2] - l[0])   
                    if np.abs(sorted_max - l[0])>50 and np.sign(slope_d)== -np.sign(slope):
                            # print(sorted_max, l[0], l[2])
                            min_len = np.linalg.norm(l[0:2] - l[2:4])
                            min_pts = l
                            x_array.append(min_pts[0])
                            x_array.append(min_pts[2])
                            y_array.append(min_pts[1])
                            y_array.append(min_pts[3])
                            min_array.append([min_pts[0],min_pts[1]])
                            min_array.append([min_pts[2],min_pts[3]])
                            # cv2.line(im_out, (min_pts[0], min_pts[1]), (min_pts[2], min_pts[3]), (0,0,255), 10, cv2.LINE_AA)
            if (len(min_array)>=2):
                
                x_array = np.array(x_array)
                A = np.vstack([x_array, np.ones(len(x_array))]).T
                y_array = np.array(y_array)
                m, c = np.linalg.lstsq(A, y_array, rcond=None)[0]
                y_plot_1 = height-40 
                x_plot_1 = int((y_plot_1 - c)/m)
                y_plot_2 = 150
                x_plot_2 = int((y_plot_2 - c)/m)
                cv2.line(im_out, (x_plot_1, y_plot_1), (x_plot_2, y_plot_2), (0,0,255), 10, cv2.LINE_AA)

            else:
                cv2.line(im_out, (x_plot_1, y_plot_1), (x_plot_2, y_plot_2), (0,0,255), 10, cv2.LINE_AA)
            im_out_1 = np.zeros(image.shape)
            im_out_1 =cv2.warpPerspective(im_out, np.linalg.inv(M), (width,height))
            masked_image = cv2.bitwise_or(image, im_out_1)
            cv2.imshow('frame', (masked_image))    
            video_output.write(masked_image)             
            if cv2.waitKey(0) & 0xFF == ord('q'):
                break
           
          
        else:
            break
cap.release()
cv2.destroyAllWindows()

"""
    dst: Output of the edge detector. It should be a grayscale image (although in fact it is a binary one)
    lines: A vector that will store the parameters (xstart,ystart,xend,yend) of the detected lines
    rho : The resolution of the parameter r in pixels. We use 1 pixel.
    theta: The resolution of the parameter Î¸ in radians. We use 1 degree (CV_PI/180)
    threshold: The minimum number of intersections to "*detect*" a line
    minLineLength: The minimum number of points that can form a line. Lines with less than this number of points are disregarded.
    maxLineGap: The maximum gap between two points to be considered in the same line.
"""