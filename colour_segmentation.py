# -*- coding: utf-8 -*-
"""q4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11uA1Mb59kz4vl37ZMdCBhBc-G0qYR8GW
"""

import cv2
import numpy as np

img = cv2.imread('Q4/Q4image.png')
# convert to RGB
cv2.imshow('input image', img)
cv2.waitKey()
cv2.destroyAllWindows()

#flattening the image for easy understanding
img_f = np.float32((np.copy(img)).reshape((-1,3)))

"""defining cluster size, taking random colours"""

K = 4
#assuming cluster with random colour values (4,3)
centroid_first = np.array(([0,0,255], [0, 255, 0], [255,255,255],[0,255,255])) #pas this to kmean menthod

print('first assumed centroid \n', centroid_first)

"""A function to find a new centroid using the updated colour clusters"""

def new_centroid(image, col_cluster, num_seg):
    size = np.zeros(num_seg)
    new_cen = np.zeros((num_seg,3))

    for i, value in enumerate(col_cluster):
        size[int(value)]+= 1
        new_cen[int(value)] += image[i]
    
    for i, c in enumerate(size):
        new_cen[i] = new_cen[i]/c
    
    return new_cen

def k_cluster(image, K, rand):
    #rand is the first chosen random color for each cluster
    #to keep this as a flag
    diff = True
    centroids = rand
    limit = 0
    cluster = np.zeros(image.shape[0])
    while diff and limit<150:
        limit = limit + 1
 #where image is the flattened image
        for i,pixel_loc in enumerate(image):
            mn_dist = float('inf')

            #distance of all points from centroids
            for id, centroid in enumerate(centroids):
                d = np.sqrt((centroid[0]-pixel_loc[0])**2 + (centroid[1] - pixel_loc[1])**2 + (centroid[2]-pixel_loc[2])**2)

                #storing closest centroid
                if mn_dist>d:
                    mn_dist = d
                    cluster[i]= id
        new_centroids = new_centroid(image, cluster, K)

        #if centroids are same then stop

        if np.count_nonzero(centroids - new_centroids)==0:
            diff = False
        else:
            centroids=new_centroids

    return centroids, cluster

cent, clust = k_cluster(img_f, K, centroid_first)

new_Img = np.copy(img_f)
#normalizing the RGB values between 0 and 1
cent = cent/255

new_Img[:] = cent[clust.flatten().astype(np.int32)]

new_Img = (new_Img.reshape(img.shape))
print('final centroid is \n', cent)

cv2.imshow('clustered image',new_Img)
cv2.waitKey(0)
cv2.destroyAllWindows()