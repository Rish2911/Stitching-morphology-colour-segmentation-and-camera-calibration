# -*- coding: utf-8 -*-
"""curve_detection_combine_it2_ouput.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k6A1_Pj-NynVu5PZ8_s7R4Nnr0NLaztZ
"""

import cv2
import numpy as np
from PIL import Image
from PIL import ImageDraw

frames = []
cap = cv2.VideoCapture('challenge.mp4')
if (cap.isOpened() == False):
	print("Unable to open the video file")
else:
  print('the video is stored in the cap variable')
video_output = cv2.VideoWriter('curve_det.avi',cv2.VideoWriter_fourcc('M','J','P','G'), 25, (1880,720))

def turn_pred(x_plot, y_plot, x_plot_y, y_plot_y):
    right_turn = 0
    left_turn = 0
    right_turn_y = 0
    left_turn_y = 0
    for i in range(len(y_plot) -1):
        m_new = ((y_plot[i+1] - y_plot[i])/(x_plot[i+1] - x_plot[i]))
        if i>0:
            m_old = ((y_plot[i] - y_plot[i-1])/(x_plot[i] - x_plot[i-1]))
            
            if (m_old - m_new)>0:
                right_turn+=1
            else:
                left_turn+=1
    if right_turn>  left_turn:
        right_curve_says = 'right turn'
    else:
        right_curve_says = 'left turn'

    for i in range(len(y_plot_y) -1):
        m_new_y = ((y_plot_y[i+1] - y_plot_y[i])/(x_plot_y[i+1] - x_plot_y[i]))
        if i>0:
            m_old_y = ((y_plot_y[i] - y_plot_y[i-1])/(x_plot_y[i] - x_plot_y[i-1]))
            
            if (m_old_y - m_new_y)>0:
                right_turn_y+=1
            else:
                left_turn_y+=1
    if right_turn_y>left_turn_y:
        left_curve_says = 'right turn'
    else:
        left_curve_says = 'left turn'
   
    if right_curve_says==left_curve_says:
        return left_curve_says
    else:
        return right_curve_says

def required_display(homographed_fit, edges2, edges, Homo_c, main, overlayed):
    h_fit = cv2.resize(homographed_fit, (300,360), interpolation = cv2.INTER_AREA)
    edg_w = cv2.resize(edges2, (300,240), interpolation = cv2.INTER_AREA)
    edg_y = cv2.resize(edges, (300,240), interpolation = cv2.INTER_AREA)
    warp = cv2.resize(Homo_c, (300,360), interpolation = cv2.INTER_AREA)
    org = cv2.resize(main, (300,240), interpolation = cv2.INTER_AREA)
    img_edg_w = np.zeros_like(org)
    img_edg_w[:,:,0] = edg_w
    img_edg_w[:,:,1] = edg_w
    img_edg_w[:,:,2] = edg_w
    img_edg_y = np.zeros_like(org)
    img_edg_y[:,:,0] = edg_y
    img_edg_y[:,:,1] = edg_y
    img_edg_y[:,:,2] = edg_y
    cv2.putText(org, str('input image'), (100,50), font, 0.5, (0,255,255),2,cv2.LINE_8)
    cv2.putText(img_edg_w, str('white and yellow edges'), (50,50), font, 0.5, (0,255,255),2,cv2.LINE_8)
    cv2.putText(img_edg_y, str('yellow edges'), (100,50), font, 0.5, (0,255,255),2,cv2.LINE_8)
    cv2.putText(warp, str('warped image'), (100,50), font, 0.5, (0,255,255),2,cv2.LINE_8)
    cv2.putText(h_fit, str('fitted curves'), (100,50), font, 0.5, (0,255,255),2,cv2.LINE_8)
    diplay = np.hstack((overlayed,np.vstack((org, img_edg_y, img_edg_w)),np.vstack((warp, h_fit))))
    # display = np.vstack((diplay,text_img))
    
    
    return diplay

#########################################################################
while(cap.isOpened()):
        ret, frame = cap.read()
        if ret == True:      
            font = cv2.FONT_HERSHEY_TRIPLEX
            image = np.copy(frame)
            #blurring the frame for noise reduction
            image = cv2.GaussianBlur(image,(3,3), 0)
            kernel = np.array([[0, -1, 0],
                   [-1, 5,-1],
                   [0, -1, 0]])
            image_sharp = cv2.filter2D(src=image, ddepth=-1, kernel=kernel)
            image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            
            height, width,_ = image.shape
            
            
            triangle = np.array([
                                [200, 675],[580, 450], [740, 440], [1175, 675]
                                ],np.float32)
            window_size_w =   320  #int(width/2)
            window_size_h = 600 #int(height/3)              
            dst_pts  = np.array([
                                [0, window_size_h],[0, 0], [window_size_w, 0], [window_size_w, window_size_h]
                                ],np.float32)
            M, mask = cv2.findHomography(triangle, dst_pts, )

            Homo_c = cv2.warpPerspective(np.copy(image_sharp), M, (window_size_w,window_size_h))
            
            #for edge detection and to get the points
            im_out_c = cv2.warpPerspective(image_gray, M, (window_size_w,window_size_h))
            im_out_f = cv2.warpPerspective(im_out_c, np.linalg.inv(M), (width,height))

            
            
            ym_per_pix = 3.048/100 # meters per pixel in y dimension, lane line is 10 ft = 3.048 meters
            xm_per_pix = 3.7/378
            
            
            
            ######yellow part####

            im_out_c_y = cv2.warpPerspective(np.copy(image_sharp), M, (window_size_w,window_size_h))
            im_out_f_y = cv2.warpPerspective(im_out_c_y, np.linalg.inv(M), (width,height))
            
            hsv = cv2.cvtColor(im_out_f_y, cv2.COLOR_BGR2HSV)
            
            lower = np.array([20, 93, 0])
            upper = np.array([65, 255, 255])

            mask = cv2.inRange(hsv, lower, upper)
            
            edges = cv2.Canny(mask,100,150)
            rho = 1
            theta = np.pi/180 #1 deg
            threshold = 5                         
            minLineLength = 5                          
            maxLineGap = 5                       
            linesP = cv2.HoughLinesP(edges, rho, theta, threshold, None, minLineLength, maxLineGap)
            yellow_x = []
            yellow_y = []
            if linesP is not None:

                for i in range(0, len(linesP)):
                    l = linesP[i][0]
                    # print(l[0], l[2])
                    if l[0]<width/2 and l[2]<width/2:
                        yellow_x.append(l[0])
                        yellow_x.append(l[2])
                        yellow_y.append(l[1])
                        yellow_y.append(l[3])
                        # cv2.line(image, (l[0],l[1]), (l[2], l[3]), (0,0,255), 5, cv2.LINE_AA)
                # print(len(yellow_x))
                if len(yellow_x)>0:
                    x_array_y = np.array(yellow_x)
                    y_array_y = np.array(yellow_y)
                    z_y = np.polyfit(x_array_y, y_array_y, 2)
                    poly_y = np.poly1d(z_y)
                
                    x_plot_y = range(280, int(width/2)-50, 1)                        
                    y_plot_y = poly_y(x_plot_y)
                    x_plot_y = np.matrix(x_plot_y).T
                    y_plot_y = np.matrix(y_plot_y).T                       
                    pts_y = np.hstack([x_plot_y,y_plot_y])
            
                    # print(y_plot_y)
                    pts_y = np.array(pts_y,np.int32)
        
                    # pts = pts.reshape((-1, 1, 2))
                    
                    isClosed = False
                    
                    # Blue color in BGR
                    color_y = (0, 255, 0)
                    
                    # Line thickness of 2 px
                    thickness = 2
                    curve_radius_y = ((1 + (2*z_y[0]*height*ym_per_pix + z_y[1])**2)**1.5) / np.absolute(2*z_y[0])
                    # cv2.putText(image, str('left curvature: ' + str(int(curve_radius_y)) + 'm'), (700, 50), font, 1, (0,0,255),1,cv2.LINE_8) 
                    cv2.polylines(image, [pts_y], isClosed, color_y, thickness)
                else:
                    # cv2.putText(image, str('left curvature ' + str(int(curve_radius_y)) + 'm'), (700,50), font, 1, (0,0,255),1,cv2.LINE_8) 
                    cv2.polylines(image, [pts_y], isClosed, color_y, thickness)
            #########################################################################################################################################

              #######usingthresholding only#########
            ret,thresh1 = cv2.threshold(im_out_f,195,255,cv2.THRESH_BINARY)

            edges2 = cv2.Canny(thresh1 ,50,200)
            Homo_edges = cv2.warpPerspective(np.copy(edges2), M, (window_size_w,window_size_h))
            rho = 1
            theta = np.pi/180 #1 deg
            threshold = 5      
            minLineLength = 5                             
            maxLineGap = 5                   
            linesP = cv2.HoughLinesP(edges2, rho, theta, threshold, None, minLineLength, maxLineGap)
            white_x = []
            white_y = []
            if linesP is not None:
                for i in range(0, len(linesP)):
                    l = linesP[i][0]
                    # print(l[0], l[2])
                    if l[0]>width/2 and l[2]>width/2:
                        white_x.append(l[0])
                        white_x.append(l[2])
                        white_y.append(l[1])
                        white_y.append(l[3])
                        # cv2.line(image, (l[0],l[1]), (l[2], l[3]), (0,0,255), 5, cv2.LINE_AA)
                print(len(white_x))
                if len(white_x)>30                :
                    
                    x_array = np.array(white_x)
                    y_array = np.array(white_y)
                    z = np.polyfit(x_array, y_array, 2)
                    poly = np.poly1d(z)
                
                    x_plot = range(745, width-200, 1)                        
                    y_plot = poly(x_plot)
                    x_plot = np.matrix(x_plot).T
                    y_plot = np.matrix(y_plot).T                       
                    pts = np.hstack([x_plot,y_plot])

                    pts = np.array(pts,np.int32)
        
                    # pts = pts.reshape((-1, 1, 2))
                    
                    isClosed = False
                    
                    # Blue color in BGR
                    color_w = (0, 0, 255)
                    thickness = 2
                    
                    
                    # if np.abs(y_max - y_min)>window_size_h/1.3:
                    cv2.polylines(image, [pts], isClosed, color_w, thickness)
                   

                    curve_radius_w = ((1 + (2*z[0]*300*ym_per_pix + z[1])**2)**1.5) / np.absolute(2*z[0])   ## 300 is the window height
                    # cv2.putText(image, str('right curvature ' + str(int(curve_radius_w)) + 'm'), (436,120), font, 1, (0,255,0),1,cv2.LINE_8)      

                else:             
                    # cv2.putText(image, str('right curvature ' + str(int(curve_radius_w)) + 'm'), (436,120), font, 1, (0,255,0),1,cv2.LINE_8) 
                    cv2.polylines(image, [pts], isClosed, color_w, thickness)
            
    
            ######transparentpoly######
            pts_poly = np.vstack((pts, pts_y))
            overlay = np.copy(image)
            overlayed_image = np.copy(image)
            alpha = 0.5
            cv2.fillPoly(overlay, pts =[pts_poly], color=(255,192,203))
            cv2.addWeighted(overlay, alpha, overlayed_image, 1 - alpha, 0, overlayed_image)
            ######################


            output = turn_pred(x_plot, y_plot, x_plot_y, y_plot_y)
            # print(output)            
            curvature = (curve_radius_y + curve_radius_w)/2
            
            
            homographed_fit= cv2.warpPerspective(image, M, (window_size_w,window_size_h))             
            display = required_display(homographed_fit, edges2, edges, Homo_c, image_sharp,overlayed_image)
            cv2.rectangle(display,(0,height-80),(width,height),(255,5,10),3)
            pts_text = [(0,height-80),(width,height-80), (width,height), (0,height)]
            pts_text = np.array(pts_text,np.int32)
            cv2.fillPoly(display, pts =[pts_text], color=(155,55,10))
            # cv2.putText(display, str('avg. curvature  is:' + str(int(curvature)) + 'm'), (50,height -40), font, 0.5, (0,255,255),2,cv2.LINE_8)
            cv2.putText(display, str('prediction: ' + output), (int(width/2)-30,int(height)-100), font, 1, (255,0,0),1,cv2.LINE_8)
            cv2.putText(display, str('left curvature is: ' + str(int(curve_radius_y)) + 'm'), (50,height -40), font, 0.7, (0,0,255),1,cv2.LINE_8)
            cv2.putText(display, str('avg. curvature  is: ' + str(int(curvature)) + 'm'), (int(width/2)-80,int(height)-40), font, 0.7, (0,255,255),2,cv2.LINE_8)
            cv2.putText(display, str('right curvature is: ' + str(int(curve_radius_w)) + 'm'), (int(width)-330,int(height)-40), font, 0.7, (0,255,0),1,cv2.LINE_8) 
            video_output.write(display)
            cv2.imshow('a', display)             
            if cv2.waitKey(0) & 0xFF == ord('q'):
                break
            
                                                           
        else:
            break
cap.release()
cv2.destroyAllWindows()

"""one channel to 3 channel

dst: Output of the edge detector. It should be a grayscale image (although in fact it is a binary one)
    lines: A vector that will store the parameters (xstart,ystart,xend,yend) of the detected lines
    rho : The resolution of the parameter r in pixels. We use 1 pixel.
    theta: The resolution of the parameter Î¸ in radians. We use 1 degree (CV_PI/180)
    threshold: The minimum number of intersections to "*detect*" a line
    minLineLength: The minimum number of points that can form a line. Lines with less than this number of points are disregarded.
    maxLineGap: The maximum gap between two points to be considered in the same line.

Check whether if the unwarped image has better performance than the warped image for detecting features
"""